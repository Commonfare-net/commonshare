
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Python functions &#8212; Commonshare 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Javascript functions" href="javascript.html" />
    <link rel="prev" title="Adjusting parameters" href="../usage/parameters.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="javascript.html" title="Javascript functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../usage/parameters.html" title="Adjusting parameters"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Commonshare 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="python-functions">
<h1>Python functions<a class="headerlink" href="#python-functions" title="Permalink to this headline">¶</a></h1>
<p>This diagram gives a basic summary of how the Python modules interact. Both <code class="docutils literal notranslate"><span class="pre">parsegexf.py</span></code> and <code class="docutils literal notranslate"><span class="pre">pagerank.py</span></code> expose their methods as a web API for <a class="reference internal" href="../usage/deployment.html#running-from-docker"><span class="std std-ref">Running from Docker</span></a>. Running from the command line is described in <a class="reference internal" href="../usage/running.html#running-commonshare"><span class="std std-ref">Running commonshare</span></a>.</p>
<a class="reference internal image-reference" href="../_images/pypeline.png"><img alt="../_images/pypeline.png" src="../_images/pypeline.png" style="width: 652.8000000000001px; height: 230.0px;" /></a>
<div class="section" id="parsegexf-py">
<h2>parsegexf.py<a class="headerlink" href="#parsegexf-py" title="Permalink to this headline">¶</a></h2>
<p>This contains method for the initial parsing phase of commonfare.net platform data. These methods refer to <code class="docutils literal notranslate"><span class="pre">parsegexf.py</span></code> in the <code class="docutils literal notranslate"><span class="pre">python/</span></code> directory, but the
version in <code class="docutils literal notranslate"><span class="pre">python_generic/</span></code> performs similar operations.</p>
<span class="target" id="module-parsegexf"></span><dl class="function">
<dt id="parsegexf.addNewAttributes">
<code class="descclassname">parsegexf.</code><code class="descname">addNewAttributes</code><span class="sig-paren">(</span><em>root</em>, <em>namespaces</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parsegexf.html#addNewAttributes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsegexf.addNewAttributes" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds all necessary node and edge attributes for use with commonfare.net</p>
<p>First, this method removes the node ‘id’ attribute (its ID is already in the GEXF)
and replaces it with a ‘platform ID’ attribute (as node IDs on commonfare.net are different
to the GEXF IDs). It also adds edge attributes for all interaction types on commonfare.net.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>root</strong> – XML root element of the GEXF file</li>
<li><strong>namespaces</strong> – string XML namespace used in the GEXF file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2-tuple - (dict of edge attribute names mapped to their IDs, ID of removed node attribute)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="parsegexf.addNodeSpell">
<code class="descclassname">parsegexf.</code><code class="descname">addNodeSpell</code><span class="sig-paren">(</span><em>node</em>, <em>attrs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parsegexf.html#addNodeSpell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsegexf.addNodeSpell" title="Permalink to this definition">¶</a></dt>
<dd><p>Add spell element to a node element. A ‘spell’ is in the form <code class="docutils literal notranslate"><span class="pre">&lt;spell</span> <span class="pre">end=&quot;2019/02/20&quot;</span> <span class="pre">start=&quot;2019/02/20&quot;</span> <span class="pre">/&gt;</span></code>
and the spells of a node determine all points at which it has been active for time-based filtering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – string node ID to add spell to</li>
<li><strong>attrs</strong> – dictionary of attributes of this spell</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="parsegexf.cleanEdges">
<code class="descclassname">parsegexf.</code><code class="descname">cleanEdges</code><span class="sig-paren">(</span><em>root</em>, <em>namespaces</em>, <em>d</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parsegexf.html#cleanEdges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsegexf.cleanEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>Methods for cleaning and parsing edges in the GEXF</p>
<p>This method does a few things: 
It deletes self-looping edges and ‘Basic Income’ transactions, as well as
those that for whatever reason do not have a recognised type.</p>
<p>It parses the label of each edge to determine its type and date (using the <code class="docutils literal notranslate"><span class="pre">parseLabel</span></code> method.
It then merges all edges betwee two nodes into a single edge containing all interactions,
their type and the date they occurred.</p>
<p>Finally, it keeps track of the earliest and latest edge occurrence, to get an overall time window
of platform interactions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>root</strong> – XML root element of the GEXF file</li>
<li><strong>namespaces</strong> – string XML namespace used in the GEXF file</li>
<li><strong>d</strong> – dict of edge attribute names mapped to their IDs</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">3-tuple - edges to delete, earliest interaction date, latest interaciton date</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="parsegexf.cleanNodes">
<code class="descclassname">parsegexf.</code><code class="descname">cleanNodes</code><span class="sig-paren">(</span><em>root</em>, <em>namespaces</em>, <em>gexf_id</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parsegexf.html#cleanNodes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsegexf.cleanNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds necessary attributes to nodes in the GEXF</p>
<p>First, this method removes the GEXF ID attribute from each node.</p>
<p>It then extracts the node’s platform ID from its label and adds 
this as the ‘platform_id’ attribute created in <code class="docutils literal notranslate"><span class="pre">addNewAttributes</span></code>.</p>
<p>Finally, it removes apostrophes from node titles/names as this can 
cause parsing errors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>root</strong> – XML root element of the GEXF file</li>
<li><strong>namespaces</strong> – string XML namespace used in the GEXF file</li>
<li><strong>gexf_id</strong> – string ID of old node ID attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="parsegexf.parse">
<code class="descclassname">parsegexf.</code><code class="descname">parse</code><span class="sig-paren">(</span><em>*gexffile</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parsegexf.html#parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsegexf.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Entry method to begin parsing the GEXF file</p>
<p>This is the method called through the Flask API to begin parsing the
GEXF file of all commonfare.net interactions. Once the GEXF is in the
correct format, it is passed to methods in the makegraphs.py module to
output JSON data for visualisation purposes</p>
</dd></dl>

<dl class="function">
<dt id="parsegexf.parseLabel">
<code class="descclassname">parsegexf.</code><code class="descname">parseLabel</code><span class="sig-paren">(</span><em>nodes</em>, <em>edges</em>, <em>edgeid</em>, <em>sourceid</em>, <em>targetid</em>, <em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parsegexf.html#parseLabel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsegexf.parseLabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Get edge type, start and end dates from label</p>
<dl class="docutils">
<dt>This method:</dt>
<dd><ol class="first last arabic simple">
<li>Adds edge spells to source and target nodes</li>
<li>Finds the type, start and end date of edge from its label</li>
</ol>
</dd>
</dl>
<p>Labels have the following format:
<code class="docutils literal notranslate"><span class="pre">conversation_13+date_start=2018/06/23+date_end=2018/06/26</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nodes</strong> – all nodes of the GEXF graph</li>
<li><strong>edges</strong> – all edges of the GEXF grpah</li>
<li><strong>edgeid</strong> – string ID of edge in GEXF</li>
<li><strong>sourced</strong> – string ID of node that is source of this edge</li>
<li><strong>targetid</strong> – string ID of node that is target of this edge</li>
<li><strong>label</strong> – string label of edge in GEXF</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">3-tuple containing edge type, start and end date</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="parsegexf.replace_source">
<code class="descclassname">parsegexf.</code><code class="descname">replace_source</code><span class="sig-paren">(</span><em>nodes</em>, <em>edges</em>, <em>edgeid</em>, <em>label</em>, <em>source</em>, <em>target</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parsegexf.html#replace_source"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parsegexf.replace_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace comment sender/receiver edge with story/writer edge</p>
<p>When a commoner leaves a comment on a story, 2 edges exist:
1) A comment sender - story edge
2) A comment sender - comment receiver edge
This replaces the sender-receiver with a story-receiver edge</p>
<a class="reference internal image-reference" href="../_images/replacesource.png"><img alt="../_images/replacesource.png" class="align-center" src="../_images/replacesource.png" style="width: 348.0px; height: 93.0px;" /></a>
<p>This is done to increase the strength of connection between users and their created stories when these stories receive comments. It also
distinguishes direct user-user interactions from indirect user-story-user interactions in the visualisation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nodes</strong> – all nodes of the GEXF graph</li>
<li><strong>edges</strong> – all edges of the GEXF grpah</li>
<li><strong>edgeid</strong> – ID of comment sender/receiver edge in GEXF</li>
<li><strong>label</strong> – label of comment sender/receiver edge in GEXF</li>
<li><strong>source</strong> – Source node of edge</li>
<li><strong>target</strong> – Target node of edge</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">string edge type (comment_story or comment_listing)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-makegraphs">
<span id="makegraphs-py"></span><h2>makegraphs.py<a class="headerlink" href="#module-makegraphs" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="makegraphs.build_commoner_data">
<code class="descclassname">makegraphs.</code><code class="descname">build_commoner_data</code><span class="sig-paren">(</span><em>G</em>, <em>commoner_graphs</em>, <em>nodes_to_remove</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/makegraphs.html#build_commoner_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#makegraphs.build_commoner_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract commoners’ interaction histories.</p>
<p>This extracts the individual interactions of each commoner
from the NetworkX graph, converts it to JSON and appends it 
to their personal interaction history, represented in the 
‘commoner_graphs’ dictionary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> – NetworkX graph of all interactions in a time window</li>
<li><strong>commoner_graphs</strong> – dictionary mapping each commoner ID to</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>their personal interaction history in JSON format
:param nodes_to_remove: list of nodes not present in this time
window (so that 0 values can be added to their JSON)</p>
</dd></dl>

<dl class="function">
<dt id="makegraphs.filter_spells">
<code class="descclassname">makegraphs.</code><code class="descname">filter_spells</code><span class="sig-paren">(</span><em>G</em>, <em>window</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/makegraphs.html#filter_spells"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#makegraphs.filter_spells" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all attributes outside time window from nodes/edges</p>
<p>This removes all the spells and actions from the nodes and edges
where they fall outside of the window slot. This makes
JSON files much less bulky and easier to read</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> – NetworkX graph</li>
<li><strong>window</strong> – 2-tuple containing start date and end date</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="makegraphs.init">
<code class="descclassname">makegraphs.</code><code class="descname">init</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/makegraphs.html#init"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#makegraphs.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Read GEXF file and initiate graph creation.</p>
<p>This reads and parses the GEXF data file, then 
calls the ‘make_all_graphs’ method with three 
different window lengths</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> – Path to the GEXF graph file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="makegraphs.jaccard">
<code class="descclassname">makegraphs.</code><code class="descname">jaccard</code><span class="sig-paren">(</span><em>front</em>, <em>stepcommunity</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/makegraphs.html#jaccard"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#makegraphs.jaccard" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Jaccard similarity coefficient of two node groups</p>
<p>This uses the Jaccard index statistic to determine whether
one node group is similar enough to a previous node group to
be part of the same dynamic community</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>front</strong> – list of NetworkX nodes at time t-1</li>
<li><strong>stepcommunity</strong> – list of NetworkX nodes at time t</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Jaccard similarity coefficient</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="makegraphs.make_all_graphs">
<code class="descclassname">makegraphs.</code><code class="descname">make_all_graphs</code><span class="sig-paren">(</span><em>G</em>, <em>startdate</em>, <em>enddate</em>, <em>spacing</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/makegraphs.html#make_all_graphs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#makegraphs.make_all_graphs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all JSON files from NetworkX graph</p>
<p>This method generates a JSON file for the cumulative
graph of interactions, JSON files for interactions within
each time window (determined by ‘spacing’ parameter) and 
JSON files for each commoner that contains their interaction 
history.
Files are created in the ‘data/output/’ directory for each 
‘spacing’ as follows:
—————
graphdata/<em>spacing</em>/0.json - JSON for all interaction data
graphdata/<em>spacing</em>/1-X.json - JSON of interaction windows,
with size dependent on the ‘spacing’ parameter
userdata/1-X.json - JSON of each commoner’s interaction
history (filename corresponds to their commoner ID)</p>
<p>Note that the output directory is within this directory 
(i.e., its path is python/data/output and not 
commonshare/data/output). This is so that the Docker container
can access the output files properly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> – NetworkX graph of all interactions across time</li>
<li><strong>startdate</strong> – date of first interaction</li>
<li><strong>enddate</strong> – date of most recent interaction</li>
<li><strong>spacing</strong> – string representing size of each time window</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>(either ‘weekly’, ‘biweekly’ or ‘monthly’</p>
</dd></dl>

<dl class="function">
<dt id="makegraphs.make_dynamic_communities">
<code class="descclassname">makegraphs.</code><code class="descname">make_dynamic_communities</code><span class="sig-paren">(</span><em>core_G</em>, <em>communities</em>, <em>index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/makegraphs.html#make_dynamic_communities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#makegraphs.make_dynamic_communities" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute new dynamic communities at a given time step.</p>
<p>Algorithm to find communities that exist in the network
across multiple time steps. At each time window, ‘static’
community detection is done with the Louvain algorithm from
<a class="reference external" href="https://github.com/taynaud/python-louvain">https://github.com/taynaud/python-louvain</a>
Then, the communities at this step are compared to those from
the previous step. If they are similar enough, they become part
of the same ‘dynamic community’. For more detail, see this paper:</p>
<p>D. Greene, D. Doyle and P. Cunningham, “Tracking the Evolution of
Communities in Dynamic Social Networks,” 2010 International 
Conference on Advances in Social Networks Analysis and Mining, 
Odense, 2010, pp. 176-183.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>core_G</strong> – NetworkX graph of all interactions in time window</li>
<li><strong>communities</strong> – list of NetworkX node ‘dynamic communities’</li>
<li><strong>index</strong> – integer representing time step</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">dictionary mapping each node to its Louvain community</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="makegraphs.make_graphs">
<code class="descclassname">makegraphs.</code><code class="descname">make_graphs</code><span class="sig-paren">(</span><em>G</em>, <em>window</em>, <em>index</em>, <em>communities</em>, <em>commoner_graphs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/makegraphs.html#make_graphs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#makegraphs.make_graphs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate JSON for NetworkX graph. Update commoner graphs.</p>
<p>This method generates all necessary information from a NetworkX
graph representation and returns it in a JSON format. It also 
updates the ‘dynamic communities’ and individual commoner graphs
(using make_dynamic_communities and build_commoner_data methods)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> – NetworkX graph of interactions in time window</li>
<li><strong>window</strong> – 2-tuple containing start and end dates</li>
<li><strong>index</strong> – integer representing time step</li>
<li><strong>communities</strong> – list holding NetworkX dynamic communities</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>(filled in by make_dynamic_communities method) 
:param commoner_graphs: dictionary mapping each commoner node to
its interaction history (filled in by build_commoner_data method)
:returns: tuple containing:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Updated dynamic communities</li>
<li>Updated commoner_graphs</li>
<li>JSON representation of NetworkX graph</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="makegraphs.make_recommender_data">
<code class="descclassname">makegraphs.</code><code class="descname">make_recommender_data</code><span class="sig-paren">(</span><em>G</em>, <em>window</em>, <em>tag_edges</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/makegraphs.html#make_recommender_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#makegraphs.make_recommender_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the GEXF used for recommending stories</p>
<p>This takes the GEXF file containing every interaction over
time and generates the ‘recommenderdata.gexf’ file, which
is used by ‘pagerank.py’ to determine stories that should be
recommended to users</p>
<p>It also makes the ‘neglected_nodes’ list, consisting of nodes
with a degree &lt; 2 and age &lt; 50 days</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> – NetworkX graph of all interactions across time</li>
<li><strong>window</strong> – A 2-tuple containing the start and end dates
of the graph actions</li>
<li><strong>tag_edges</strong> – List of NetworkX edges to tag nodes</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-kcore">
<span id="kcore-py"></span><h2>kcore.py<a class="headerlink" href="#module-kcore" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="kcore.colluding">
<code class="descclassname">kcore.</code><code class="descname">colluding</code><span class="sig-paren">(</span><em>G</em>, <em>n1</em>, <em>n2</em>, <em>n1_weight</em>, <em>n2_weight</em>, <em>window</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/kcore.html#colluding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kcore.colluding" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if two nodes are colluding</p>
<p>Basic collusion checking algorithm. Determines if actions from
one node are greater than a threshold of the recipient node’s
overall weight. The threshold is defined in config.py</p>
<p>Algorithm adapted from the following paper:
H.Shen, Y.Lin, K.Sapra and Z.Li, “Enhancing Collusion Resilience
in Reputation Systems,” in IEEE Transactions on Parallel and 
Distributed Systems, vol.27, no.8, pp.2274-2287, 1 Aug. 2016.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>G</strong> – NetworkX graph of all interactions in a time window</li>
<li><strong>n1</strong> – string representing Node 1 ID</li>
<li><strong>n2</strong> – string representing Node 2 ID</li>
<li><strong>n1_weight</strong> – float, sum of edge weights of Node 1</li>
<li><strong>n2_weight</strong> – float, sum of edge weights of Node 2</li>
<li><strong>window</strong> – 2-tuple of start and end dates of time window</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">bool, True if strong suspicion of collusion.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="kcore.nodeweight">
<code class="descclassname">kcore.</code><code class="descname">nodeweight</code><span class="sig-paren">(</span><em>G</em>, <em>node_id</em>, <em>window</em>, <em>suspect_nodes</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/kcore.html#nodeweight"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kcore.nodeweight" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate weight of a node in the interactions graph.</p>
<p>This calculates a node’s ‘weight’ by looking at the 
number, type, and date of interactions with other nodes 
in the graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> – NetworkX graph of all interactions in a time window</li>
<li><strong>node_id</strong> – string ID of node to determine weight of</li>
<li><strong>window</strong> – 2-tuple with start and end dates of time window</li>
<li><strong>suspect_nodes</strong> – dictionary mapping node ID’s of high</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>activity to their overall weight</p>
</dd></dl>

<dl class="function">
<dt id="kcore.weighted_core">
<code class="descclassname">kcore.</code><code class="descname">weighted_core</code><span class="sig-paren">(</span><em>G</em>, <em>window</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/kcore.html#weighted_core"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kcore.weighted_core" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute weighted k-core for each node in a graph</p>
<p>This extends the standard NetworkX k-core calculation method 
by weighting each node based on its platform interactions, 
performing a log-transformation and normalising the final value 
to an integer between 1 and 10
It only returns a list of colluding nodes as the NetworkX graph
is passed by reference and updated anyway</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>G</strong> – NetworkX graph of all interactions in a time window</li>
<li><strong>window</strong> – 2-tuple of start and end dates of time window</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of potential colluding nodes</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pagerank">
<span id="pagerank-py"></span><h2>pagerank.py<a class="headerlink" href="#module-pagerank" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pagerank.personalisedPageRank">
<code class="descclassname">pagerank.</code><code class="descname">personalisedPageRank</code><span class="sig-paren">(</span><em>core_graph</em>, <em>story</em>, <em>user</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pagerank.html#personalisedPageRank"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pagerank.personalisedPageRank" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute personalised PageRank of stories for given user</p>
<p>This uses NetworkX’s built in Personalised PageRank algorithm
to compute PageRank value of other stories on the platform 
for a given user reading a given story</p>
<p>More info on the algorithm and its personalisation in:</p>
<p>Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). 
The PageRank citation ranking: Bringing order to the web. 
Stanford InfoLab.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>core_graph</strong> – NetworkX graph of platform interactions with additional data on neglected nodes and edge weights</li>
<li><strong>story</strong> – string ID of story a user is reading</li>
<li><strong>user</strong> – string ID of platform user (or 0 if not logged in)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">dictionary of story IDs mapped to their PageRank value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pagerank.run">
<code class="descclassname">pagerank.</code><code class="descname">run</code><span class="sig-paren">(</span><em>storyid</em>, <em>userid</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pagerank.html#run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pagerank.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Return three recommended stories for user reading a story</p>
<p>This uses the personalised pagerank algorithm to return the IDs
of three stories that a user should be recommended on reading a
particular story. The method is routed using the Flask API to 
the ‘/recommend’ URL, which also contains the parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>storyid</strong> – string ID of story user is reading</li>
<li><strong>userid</strong> – string ID of user</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-simulation">
<span id="simulation-py"></span><h2>simulation.py<a class="headerlink" href="#module-simulation" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="simulation.add_tag">
<code class="descclassname">simulation.</code><code class="descname">add_tag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/simulation.html#add_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#simulation.add_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a tag node to the graph</p>
</dd></dl>

<dl class="function">
<dt id="simulation.add_user">
<code class="descclassname">simulation.</code><code class="descname">add_user</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/simulation.html#add_user"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#simulation.add_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a user node to the graph</p>
</dd></dl>

<dl class="function">
<dt id="simulation.create_object">
<code class="descclassname">simulation.</code><code class="descname">create_object</code><span class="sig-paren">(</span><em>user</em>, <em>objtype</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/simulation.html#create_object"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#simulation.create_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Create object and edge between it and its creating user</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>user</strong> – string ID of user who created object</li>
<li><strong>objtype</strong> – string type of object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="simulation.do_random_thing">
<code class="descclassname">simulation.</code><code class="descname">do_random_thing</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/simulation.html#do_random_thing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#simulation.do_random_thing" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a random interaction to perform this turn</p>
<p>This uses a random number generator to determine an action to perform in
the simulation. Interactions can be made more likely simply by having 
more result numbers correspond to them</p>
</dd></dl>

<dl class="function">
<dt id="simulation.get_users">
<code class="descclassname">simulation.</code><code class="descname">get_users</code><span class="sig-paren">(</span><em>need_two_users</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/simulation.html#get_users"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#simulation.get_users" title="Permalink to this definition">¶</a></dt>
<dd><p>Return two random user nodes from graph</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>need_two_users</strong> – bool, True if 2 users are needed</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list containing one or two user IDs</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="simulation.object_interact">
<code class="descclassname">simulation.</code><code class="descname">object_interact</code><span class="sig-paren">(</span><em>objtype</em>, <em>interaction</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/simulation.html#object_interact"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#simulation.object_interact" title="Permalink to this definition">¶</a></dt>
<dd><p>Create edge between user node and story/listing node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>objtype</strong> – string type of object</li>
<li><strong>interaction</strong> – string type of interaction</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="simulation.str_to_class">
<code class="descclassname">simulation.</code><code class="descname">str_to_class</code><span class="sig-paren">(</span><em>classname</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/simulation.html#str_to_class"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#simulation.str_to_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a string to a class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>classname</strong> – string name of class to access</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">class corresponding to name</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="simulation.tag_assign">
<code class="descclassname">simulation.</code><code class="descname">tag_assign</code><span class="sig-paren">(</span><em>thing</em>, <em>tag</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/simulation.html#tag_assign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#simulation.tag_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Create edge between a tag node and a user/story/listing node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>thing</strong> – string ID of a user, story or listing node</li>
<li><strong>tag</strong> – string ID of a tag node</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="simulation.update">
<code class="descclassname">simulation.</code><code class="descname">update</code><span class="sig-paren">(</span><em>source</em>, <em>target</em>, <em>interaction</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/simulation.html#update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#simulation.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update stats of nodes and edge between them with an interaction</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> – string ID of interaction source node</li>
<li><strong>target</strong> – string ID of interaction target node</li>
<li><strong>interaction</strong> – string interaction type</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="simulation.user_interact">
<code class="descclassname">simulation.</code><code class="descname">user_interact</code><span class="sig-paren">(</span><em>interaction</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/simulation.html#user_interact"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#simulation.user_interact" title="Permalink to this definition">¶</a></dt>
<dd><p>Create edge between two user nodes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>interaction</strong> – string type of interaction taking place</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Python functions</a><ul>
<li><a class="reference internal" href="#parsegexf-py">parsegexf.py</a></li>
<li><a class="reference internal" href="#module-makegraphs">makegraphs.py</a></li>
<li><a class="reference internal" href="#module-kcore">kcore.py</a></li>
<li><a class="reference internal" href="#module-pagerank">pagerank.py</a></li>
<li><a class="reference internal" href="#module-simulation">simulation.py</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../usage/parameters.html"
                        title="previous chapter">Adjusting parameters</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="javascript.html"
                        title="next chapter">Javascript functions</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/functions/python.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="javascript.html" title="Javascript functions"
             >next</a> |</li>
        <li class="right" >
          <a href="../usage/parameters.html" title="Adjusting parameters"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Commonshare 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Daniel Rough.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>